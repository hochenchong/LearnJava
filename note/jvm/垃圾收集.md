## 垃圾收集
### 三个问题
> * 哪些内存需要回收？
> * 什么时候回收？
> * 如何回收？

--- 

### 确定对象的存活情况
#### 引用计数算法（Reference Counting）
> * 思想：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加 1；当引用失效时，则减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。
> 
> * 优点：实现简单，效率高 
> * 缺点：很难解决对象之间相互循环引用的问题（Java 虚拟机里没有选用引用计数算法来管理内存的最主要的原因）

#### 可达性分析算法（Reachability Chain）
> * 思想：通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。
> * Java 中，可作为 GC Roots 的对象包括以下几种：
>  * 虚拟机栈（栈帧中的本地变量表）中引用的对象
>  * 方法区中类静态属性引用的对象
>  * 方法区中常量引用的对象
>  * 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

---

### 垃圾收集算法
    标记-清除（Mark-Sweep）算法
        算法分为 “标记” 和 “清除” 阶段
        标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
        不足：
            效率问题，标记和清除两个过程的效率都不高
            空间问题，标记清楚之后会产生大量不连续的内存碎片，以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

    复制（Copying）算法
        将可用内存按容量划分为大小相等的两块，每次只使用其中的一块
        当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
        优点：实现简单，运行高效
        缺点：内存缩小为了原来的一半
        现状：
            现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是 “朝生夕死” 的。
            新生代中将内存分为一块较大的 Eden 空间和两个较小的 Survivor 空间。每次使用 Eden 和其中一块 Survivor。
            HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1。
            回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。
            当 Survivor 空间不够用时，则通过分配担保（Handle Promotion）将对象保存到老年代之中。

    标记-整理（Mark-Compact）算法
        根据老年代的特点（对象存活率高、没有额外空间对它进行分配担保），提出来的算法。
        标记过程与 “标记-清除” 算法一样，标记之后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

    分代收集（Generational Collection）算法
        当前商业虚拟机的垃圾收集都采用这种算法，根据对象存活周期的不同将内存划分为几块。
        一般是把 Java 堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。
        新生代：垃圾收集时只有少量存活，选用复制算法，只需付出少量存活对象的复制成本就可以完成收集
        老年代：因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记-清理” 或者 “标记-整理” 算法来进行回收